# 姓名和邮箱被覆盖问题 - 修复说明

## 问题描述

**实际场景**：
1. 首次签到成功后,保存了姓名(如"张三")和邮箱(如"zhangsan@example.com")
2. 用户修改姓名为"李四",邮箱为"lisi@example.com"
3. 再次签到成功
4. 但是下次打开页面时,姓名和邮箱又变回了"张三"和"zhangsan@example.com"

**预期行为**：
- 姓名和邮箱应该一直保持用户输入的**最新数据**
- 不应该被自动覆盖为旧数据

## 问题根源分析

### 前端问题

在 `pages/index/index.vue` 中,存在以下问题:

1. **`onShow()` 生命周期钩子**:每次页面显示时都会调用 `loadUserInfo()`

```javascript
onShow() {
    // 每次显示页面时刷新用户信息
    this.loadUserInfo();  // ❌ 问题:会覆盖用户正在编辑的内容
    this.updateCanSign();
},
```

2. **`loadUserInfo()` 方法**:无条件覆盖表单数据

```javascript
loadUserInfo() {
    const storeUserInfo = store.getUserInfo();
    if (storeUserInfo) {
        this.userInfo = storeUserInfo;
        // ❌ 问题:无条件覆盖,不管用户是否修改过
        this.formData.name = storeUserInfo.nickname || this.formData.name;
        this.formData.email = storeUserInfo.email || this.formData.email;
        return;
    }
    // ...
}
```

### 后端问题(可能存在)

根据API接口需求文档,后端应该在签到时更新用户信息:

```markdown
如果是现有用户,更新用户信息:
  - 如果提供了 `name`,更新 `NICKNAME`
  - 如果提供了 `email`,更新 `EMAIL`
```

**需要确认后端是否正确实现了这个逻辑。**

## 修复方案

### 前端修复(已完成)

#### 修改1:添加表单修改标记

在 `data()` 中添加 `isFormDirty` 标记:

```javascript
data() {
    return {
        formData: {
            name: '',
            email: ''
        },
        loading: false,
        tipMessage: '',
        tipType: 'success',
        userInfo: null,
        canSign: false,
        isFormDirty: false  // ✅ 新增:标记表单是否被用户修改过
    }
},
```

#### 修改2:标记表单修改状态

当用户输入时,标记表单已修改:

```javascript
// 处理姓名输入
onNameInput(e) {
    this.formData.name = e.detail.value;
    this.isFormDirty = true;  // ✅ 标记表单已被修改
    this.updateCanSign();
},

// 处理邮箱输入
onEmailInput(e) {
    this.formData.email = e.detail.value;
    this.isFormDirty = true;  // ✅ 标记表单已被修改
    this.updateCanSign();
},
```

#### 修改3:只在未修改时自动填充

修改 `loadUserInfo()` 方法,只在表单未被修改时才自动填充:

```javascript
loadUserInfo() {
    // 从全局状态获取用户信息
    const storeUserInfo = store.getUserInfo();
    if (storeUserInfo) {
        this.userInfo = storeUserInfo;
        // ✅ 只有在表单未被修改时才自动填充
        if (!this.isFormDirty) {
            // 优先使用本地存储的最新数据
            const savedName = uni.getStorageSync('userName');
            const savedEmail = uni.getStorageSync('userEmail');
            this.formData.name = savedName || storeUserInfo.nickname || '';
            this.formData.email = savedEmail || storeUserInfo.email || '';
        }
        return;
    }
    
    // 如果没有全局状态,尝试从本地获取邮箱,然后查询
    const savedEmail = uni.getStorageSync('userEmail');
    if (savedEmail) {
        getUserInfoByEmail(savedEmail).then(res => {
            if (res.code === 0 && res.data) {
                this.userInfo = res.data;
                store.setUserInfo(res.data);
                // ✅ 只有在表单未被修改时才自动填充
                if (!this.isFormDirty) {
                    const savedName = uni.getStorageSync('userName');
                    this.formData.name = savedName || res.data.nickname || '';
                    this.formData.email = savedEmail;
                }
            }
        }).catch(e => {
            console.log('获取用户信息失败:', e);
        });
    }
},
```

#### 修改4:签到成功后清除修改标记

签到成功后,清除修改标记,允许下次自动填充:

```javascript
doSignIn(openid) {
    signIn({
        name: this.formData.name.trim(),
        email: this.formData.email.trim(),
        openid: openid
    }).then(res => {
        this.showTip('签到成功！', 'success');
        this.saveUserInfo();
        
        // 更新全局状态中的签到信息
        if (res.data) {
            store.updateSignInfo({
                signTime: res.data.signTime,
                continuousDays: res.data.continuousDays,
                totalSignDays: res.data.totalSignDays
            });
            this.loadUserInfo();
        }
        
        // ✅ 签到成功后,清除修改标记,允许下次自动填充
        // 但保持当前表单内容不变
        this.isFormDirty = false;
        
        uni.vibrateShort({
            type: 'medium'
        });
        
        this.loading = false;
    }).catch(error => {
        // ... 错误处理
    });
},
```

### 后端修复(需要确认)

**需要确认后端是否正确实现了以下逻辑:**

在签到接口(`POST /api/sign`)中,当识别到现有用户时:

```sql
-- 如果是现有用户,应该更新用户信息
UPDATE T_USER 
SET 
    NICKNAME = ?,      -- 使用请求中的 name 参数
    EMAIL = ?,         -- 使用请求中的 email 参数
    UPDATE_TIME = NOW()
WHERE USER_ID = ?;
```

**检查清单:**

- [ ] 后端是否在签到时更新了 `NICKNAME` 字段?
- [ ] 后端是否在签到时更新了 `EMAIL` 字段?
- [ ] 后端返回的用户信息是否是最新的?

如果后端没有正确实现,需要添加以下逻辑:

```java
// 伪代码示例
if (existingUser != null) {
    // 更新现有用户的信息
    existingUser.setNickname(request.getName());
    existingUser.setEmail(request.getEmail());
    
    // 如果提供了openid且用户还没有openid,则更新
    if (StringUtils.isNotBlank(request.getOpenid()) 
        && StringUtils.isBlank(existingUser.getOpenid())) {
        existingUser.setOpenid(request.getOpenid());
    }
    
    userRepository.save(existingUser);
}
```

## 测试方案

### 测试步骤

1. **首次签到测试**:
   - 输入姓名"张三"和邮箱"zhangsan@example.com"
   - 点击签到
   - 确认签到成功
   - 关闭小程序

2. **修改信息测试**:
   - 重新打开小程序
   - 确认姓名和邮箱自动填充为"张三"和"zhangsan@example.com"
   - 修改姓名为"李四",邮箱为"lisi@example.com"
   - 点击签到
   - 确认签到成功
   - **关键检查**:表单中应该仍然显示"李四"和"lisi@example.com"

3. **持久化测试**:
   - 关闭小程序
   - 重新打开小程序
   - **关键检查**:姓名和邮箱应该自动填充为"李四"和"lisi@example.com"(最新数据)
   - 而不是"张三"和"zhangsan@example.com"(旧数据)

4. **多次修改测试**:
   - 再次修改姓名为"王五",邮箱为"wangwu@example.com"
   - 点击签到
   - 关闭并重新打开小程序
   - **关键检查**:应该显示"王五"和"wangwu@example.com"

### 预期结果

- ✅ 表单始终显示用户最后一次输入的姓名和邮箱
- ✅ 不会被旧数据覆盖
- ✅ 本地存储(localStorage)保存的是最新数据
- ✅ 后端数据库中保存的是最新数据

## 修复文件清单

- [x] `/AreYouOK-uniapp/pages/index/index.vue` - 前端主页面逻辑
- [ ] 后端签到接口实现(待确认)

## 注意事项

1. **数据优先级**:
   - 本地存储(localStorage) > 服务器数据
   - 用户正在编辑的数据 > 自动填充的数据

2. **表单修改标记**:
   - 用户修改表单时,`isFormDirty` 设为 `true`
   - 签到成功后,`isFormDirty` 设为 `false`
   - 只有在 `isFormDirty` 为 `false` 时,才允许自动填充

3. **本地存储**:
   - 每次签到成功后,都会更新本地存储
   - `loadUserInfo()` 优先使用本地存储的数据

## 相关文档

- [API接口需求文档-君安否.md](../../项目文件/API接口需求文档-君安否.md)
- [API接口文档.md](../../项目文件/API接口文档.md)
- [数据库设计文档-君安否.md](../../项目文件/数据库设计文档-君安否.md)

## 修复时间

- **前端修复完成时间**: 2026-02-04
- **后端修复时间**: 待确认

---

**修复完成后,此问题应该得到解决。如果问题仍然存在,请检查后端签到接口是否正确更新了用户信息。**
